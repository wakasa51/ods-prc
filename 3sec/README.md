### 3-1 SLList において、push(x)、pop()、add(x)、remove() の特殊なケースすべて をダミーノードを使って避けられないのはなぜか。
pop：最後の要素を削除する場合は特別で、tailをNULLに設定する。

→要素数が0の時にdummyのtailにnullを設定する必要がある。

add：n=0の場合は特別でtail=head=nullとする。この場合、tailもheadもuになる。

→n=0の場合、dummyのtailとheadにnullを入れる必要がある。

remove：n=0の場合は特別でtail=head=nullとする。この場合、tailもheadもuになる。

→addと同じ

### 3-2 SLListのメソッドsecondLast()を設計、実装せよ。これはSLListの末尾の 1 つ前の要素を返すメソッドである。リストの要素数 n を使わずに実装してみよ。
headから要素を辿り、current->next == tailになるまで探索し続ける。
### 3-3 SLListのget(i)、set(i,x)、add(i,x)、remove(i)を実装せよ。いずれの操 作の実行時間もO(1+i)であること。
SLListに実装。
### 3-4 SLListのreverse()操作を設計、実装せよ。これはSLListの要素の順番を逆 にする操作である。この操作の実行時間は O(n) でなければならず、再帰を使ってはならな い。また、他のデータ構造を補助的に使ったり、新しいノードを作ったりしてもいけない。
### 3-5 SLListおよびDLListのメソッドcheckSize()を設計、実装せよ。これはリス トを辿り、n の値がリストに入っている要素の数と一致するかを確認するメソッドである。 このメソッドは何も返さないが、もし要素数が n と一致しなければ例外を投げる。
### 3-6 addBefore(w)を再実装せよ。これはノードuを作り、それをノードwの直前に 追加する操作だ。本章のコードは参照しないこと。本章のコードと完全に一致しなくても、 正しいコードになっている可能性はある。自分が書いたコードをテストし、正しく動くか どうかを確認せよ。
### 3-7 DLListのメソッドisPalindrome()を実装せよ。これはリストが回文であると きtrueを返す。すなわち、任意のi ∈ {0,...,n−1}について、i番めの要素とn−i−1番め の要素が等しいかどうかを確認する。実行時間は O(n) であること。
### 3-8 メソッドrotate(r)を実装せよ。これはDLListの要素を回転し、i番めの要素 を(i+r) modn番めの位置に移動する。実行時間はO(1+min{r,n−r})であること。リ スト内のノードを修正してはならない。
### 3-9 メソッドtruncate(i)を実装せよ。これはDLListをi番めで切り詰める。この メソッドを実行すると、リストの要素数は i になり、0, . . . , i − 1 番めの要素だけが残る。返 り値は、i,...,n−1番めの要素を含む別のDLListである。実行時間はO(min{i,n−i}) であること
### 3-10  DLListのメソッドabsorb(l2)を実装せよ。引数として別のDLList(l2)を 取り、l2 を空にしてその中身を自分の要素として追加する。例えば、l1 が a, b, c を含み、 l2がd,e,f を含むとき、l1.absorb(l2)を実行すると、l1はa,b,c,d,e,f を含み、l2は 空になる。
### 3-11 deal()を実装せよ。これはDLListから偶数番めの要素を削除し、それらの要 素を含むDLListを返す操作だ。例えばl1が a,b,c,d,e,f を含むとき、l1.deal() を呼ぶ と、l1の要素は a,c,e になり、b,d,f を含むリストが返される。
### 3-12 メソッドreverse()を実装せよ。これはDLListの要素の順序を逆転する
### 3-13 この問題ではDLListを整列するマージソートというアルゴリズムを実装することになる。マージソートは 11.1.1 節で扱う。
#### 1 DLListのメソッドtakeFirst(l2) を実装せよ。これはl2の先頭ノードを取 り出してレシーバーに追加する。新しいノードを作らないことを除けば、 add(size(),l2.remove(0)) と等価である。
#### 2 DLListの静的メソッドmerge(l1,l2)を実装せよ。これは2つの整列済みのリスト l1 と l2 を統合し、その結果を含む新たな整列済みリストを返す。この操作により l1とl2は空になる。例えば、l1の要素が a,c,d、l2の要素が b,e,f であるとき、 このメソッドはa,b,c,d,e,f を含むリストを返す。
#### 3 DLListのメソッドsort()を実装せよ。これはマージソートを使ってリストのすべ ての要素を整列する。この再帰的なアルゴリズムは次のように動作する。
(a)リストの要素数が 0 または 1 なら何もしない (b)そうでないなら、truncate(size()/2) によって、リストをほぼ等しい大き
さの2つのリストl1とl2に分割する
(c)再帰的に l1 を整列する
(d)再帰的に l2 を整列する
(e)最後に l1 と l2 を統合して 1 つの整列済みリストとする
### 3-14 データ構造MinStackを設計、実装せよ。これは比較可能な要素を持ち、スタッ クの操作 push(x)、pop()、size() をサポートし、min() 操作も可能なデータ構造である。 min() はデータ構造に入っている要素のうち最小の値を返す。すべての操作の実行時間は 定数であること。
### 3-15 データ構造MinQueueを設計、実装せよ。これは比較可能な要素を持ち、キュー の操作 add(x)、remove()、size() をサポートし、min() 操作も可能なデータ構造である。 すべての操作の償却実行時間は定数であること。
### 3-16 データ構造 MinDeque を設計、実装せよ。これは比較可能な要素を持ち、双方 向キューの操作 addFirst(x)、addLast(x)、removeFirst()、removeLast()、size() をサポートし、min() 操作も可能なものである。すべての操作の償却実行時間は定数であ ること。
### 3-17 SEListがStackのように使われるとき、つまりSEListがpush(x) ≡ add(size(),x)とpop() ≡remove(size()−1)によってのみ更新されるとき、これら の操作の償却実行時間がいずれも b の値に依存しない定数であることを証明せよ。
### 3-18 Dequeの操作をすべてサポートし、いずれの償却実行時間もbに依存しない定 数であるような SEList を設計、実装せよ。
### 3-19 ビット単位の排他的論理和 ^ によって 2 つの int 型の値を入れ替える方法を説 明せよ。ただし、その際に 3 つめの変数を使ってはならないものとする。

